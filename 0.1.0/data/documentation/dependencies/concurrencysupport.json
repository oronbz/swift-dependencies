{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a small number of concurrency tools that can be handy when constructing"},{"type":"text","text":" "},{"type":"text","text":"dependency implementations and testing features that use dependencies."}]},{"anchor":"ActorIsolated-and-LockIsolated","level":3,"type":"heading","text":"ActorIsolated and LockIsolated"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/ActorIsolated"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/LockIsolated"},{"type":"text","text":" types help wrap other values in an isolated context."},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/ActorIsolated"},{"type":"text","text":" wraps the value in an actor so that the only way to access and mutate the value is"},{"type":"text","text":" "},{"type":"text","text":"through an async\/await interface. "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/LockIsolated"},{"type":"text","text":" wraps the value in a class with a lock, which"},{"type":"text","text":" "},{"type":"text","text":"allows you to read and write the value with a synchronous interface. You should prefer to use"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/ActorIsolated"},{"type":"text","text":" when you have access to an asynchronous context."}]},{"anchor":"AsyncStream-and-AsyncThrowingStream","level":3,"type":"heading","text":"AsyncStream and AsyncThrowingStream"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with numerous helper APIs spread across the two Swift stream types:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There are helpers that erase any "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" conformance to either concrete stream type."},{"type":"text","text":" "},{"type":"text","text":"This allows you to treat the stream type as a kind of “type erased” "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have a dependency client like this:"}]},{"type":"codeListing","syntax":"swift","code":["struct ScreenshotsClient {","  var screenshots: () -> AsyncStream<Void>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then you can construct a live implementation that “erases” the"},{"type":"text","text":" "},{"type":"codeVoice","code":"NotificationCenter.Notifications"},{"type":"text","text":" async sequence to a stream:"}]},{"type":"codeListing","syntax":"swift","code":["extension ScreenshotsClient {","  static let live = Self(","    screenshots: {","      NotificationCenter.default","        .notifications(named: UIApplication.userDidTakeScreenshotNotification)","        .map { _ in }","        .eraseToStream()  \/\/ ⬅️","    }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"eraseToThrowingStream()"},{"type":"text","text":" to propagate failures from throwing async sequences."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There is an API for simultaneously constructing a stream and its backing continuation. This can"},{"type":"text","text":" "},{"type":"text","text":"be handy in tests when overriding a dependency endpoint that returns a stream:"}]},{"type":"codeListing","syntax":"swift","code":["let screenshots = AsyncStream<Void>.streamWithContinuation()","","let model = withDependencies {","  $0.screenshots = { screenshots.stream }","} operation: {","  FeatureModel()","}","","XCTAssertEqual(model.screenshotCount, 0)","screenshots.continuation.yield()  \/\/ Simulate a screenshot being taken.","XCTAssertEqual(model.screenshotCount, 1)"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Static "},{"type":"codeVoice","code":"AsyncStream.never"},{"type":"text","text":" and "},{"type":"codeVoice","code":"AsyncThrowingStream.never"},{"type":"text","text":" helpers are provided that represent"},{"type":"text","text":" "},{"type":"text","text":"streams that live forever and never emit. They can be handy in tests that need to override a"},{"type":"text","text":" "},{"type":"text","text":"dependency endpoint with a stream that should suspend and never emit for the duration test."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Static "},{"type":"codeVoice","code":"AsyncStream.finished"},{"type":"text","text":" and "},{"type":"codeVoice","code":"AsyncThrowingStream.finished(throwing:)"},{"type":"text","text":" helpers are provided"},{"type":"text","text":" "},{"type":"text","text":"that represents streams that complete immediately without emitting. They can be handy in tests"},{"type":"text","text":" "},{"type":"text","text":"that need to override a dependency endpoint with a stream that completes\/fails immediately."}]}]}]},{"anchor":"Task","level":3,"type":"heading","text":"Task"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a static function, "},{"type":"codeVoice","code":"Task.never()"},{"type":"text","text":", that can asynchronously return a value of"},{"type":"text","text":" "},{"type":"text","text":"any type, but does so by suspending forever. This can be useful for satisfying a dependency"},{"type":"text","text":" "},{"type":"text","text":"requirement in a way that does not require you to actually return data from that endpoint."}]},{"anchor":"UncheckedSendable","level":3,"type":"heading","text":"UncheckedSendable"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A wrapper type that can make any type "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":", but in an unsafe and unchecked way. This type"},{"type":"text","text":" "},{"type":"text","text":"should only be used as an alternative to "},{"type":"codeVoice","code":"@preconcurrency import"},{"type":"text","text":", which turns off concurrency"},{"type":"text","text":" "},{"type":"text","text":"checks for everything in the library. Whereas "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/UncheckedSendable"},{"type":"text","text":" allows you to turn off"},{"type":"text","text":" "},{"type":"text","text":"concurrency warnings for just one single usage of a particular type."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/dependencies\/concurrencysupport"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Dependencies\/documentation\/Dependencies\/ConcurrencySupport","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn about the concurrency tools that come with the library that make writing tests and"},{"type":"text","text":" "},{"type":"text","text":"implementing dependencies easy."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Concurrency support","role":"article","modules":[{"name":"Dependencies"}]},"hierarchy":{"paths":[["doc:\/\/Dependencies\/documentation\/Dependencies"]]},"references":{"doc://Dependencies/documentation/Dependencies/ActorIsolated":{"role":"symbol","title":"ActorIsolated","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ActorIsolated"}],"abstract":[{"type":"text","text":"A generic wrapper for isolating a mutable value to an actor."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/ActorIsolated","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ActorIsolated"}],"url":"\/documentation\/dependencies\/actorisolated"},"doc://Dependencies/documentation/Dependencies/LockIsolated":{"role":"symbol","title":"LockIsolated","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"LockIsolated"}],"abstract":[{"type":"text","text":"A generic wrapper for isolating a mutable value with a lock."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/LockIsolated","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"LockIsolated"}],"url":"\/documentation\/dependencies\/lockisolated"},"doc://Dependencies/documentation/Dependencies":{"role":"collection","title":"Dependencies","abstract":[{"type":"text","text":"A dependency management library inspired by SwiftUI’s “environment.”"}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies","kind":"symbol","type":"topic","url":"\/documentation\/dependencies"},"doc://Dependencies/documentation/Dependencies/UncheckedSendable":{"role":"symbol","title":"UncheckedSendable","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UncheckedSendable"}],"abstract":[{"type":"text","text":"A generic wrapper for turning any non-"},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" type into a "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" one, in an unchecked"},{"type":"text","text":" "},{"type":"text","text":"manner."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/UncheckedSendable","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"UncheckedSendable"}],"url":"\/documentation\/dependencies\/uncheckedsendable"}}}