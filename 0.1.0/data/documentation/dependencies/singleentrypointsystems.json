{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A system is said to have a “single entry point” if there is one place to invoke all of its logic and"},{"type":"text","text":" "},{"type":"text","text":"behavior. Such systems make it easy to alter the execution context a system runs in, which can be"},{"type":"text","text":" "},{"type":"text","text":"powerful."}]},{"anchor":"Examples-of-single-entry-point-systems","level":2,"type":"heading","text":"Examples of single entry point systems"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By far the most popular example of this in the Apple ecosystem is SwiftUI views. A view is a type"},{"type":"text","text":" "},{"type":"text","text":"conforming to the "},{"type":"codeVoice","code":"View"},{"type":"text","text":" protocol and exposing a single "},{"type":"codeVoice","code":"body"},{"type":"text","text":" property that returns the view"},{"type":"text","text":" "},{"type":"text","text":"hierarchy:"}]},{"type":"codeListing","syntax":"swift","code":["struct FeatureView: View {","  var body: some View {","    \/\/ All of the view is constructed in here...","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is only one way to create the actual views that SwiftUI will render to the screen, and that"},{"type":"text","text":" "},{"type":"text","text":"is by invoking the "},{"type":"codeVoice","code":"body"},{"type":"text","text":" property, though we never need to actually do that. SwiftUI hides all of"},{"type":"text","text":" "},{"type":"text","text":"that from us in the "},{"type":"codeVoice","code":"@main"},{"type":"text","text":" entry point of the application or in "},{"type":"codeVoice","code":"UIHostingController"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"http:\/\/github.com\/pointfreeco\/swift-composable-architecture"},{"type":"text","text":" is another example of a single entry point system, but this"},{"type":"text","text":" "},{"type":"text","text":"time for implementing logic and behavior of a view. It provides a protocol that one conforms to and"},{"type":"text","text":" "},{"type":"text","text":"it has a single requirement, "},{"type":"codeVoice","code":"reduce"},{"type":"text","text":", which is responsible for mutating the feature’s state and"},{"type":"text","text":" "},{"type":"text","text":"returning effects to execute:"}]},{"type":"codeListing","syntax":"swift","code":["import ComposableArchitecture","","struct Feature: ReducerProtocol {","  struct State {","    \/\/ ...","  }","  enum Action {","    \/\/ ...","  }","","  func reduce(into state: inout State, action: Action) -> EffectTask<Action> {","    \/\/ All of the feature's logic and behavior is implemented here...","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Again, there is only one way to execute this feature’s logic, and that is by invoking the "},{"type":"codeVoice","code":"reduce"},{"type":"text","text":" "},{"type":"text","text":"method. However, you never actually need to do that in practice. The Composable Architecture"},{"type":"text","text":" "},{"type":"text","text":"hides all of that from you, and instead you just construct a "},{"type":"codeVoice","code":"Store"},{"type":"text","text":" at the root of the application."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another example of a single entry point system is a server framework. Such frameworks usually"},{"type":"text","text":" "},{"type":"text","text":"have a simple request-to-response lifecycle. It starts by the framework receiving a request from an"},{"type":"text","text":" "},{"type":"text","text":"external client. Then one uses the framework’s tools in order to interpret that request and build"},{"type":"text","text":" "},{"type":"text","text":"up a response to send back to the client. This again describes just a single point for all logic to"},{"type":"text","text":" "},{"type":"text","text":"be executed for a particular request."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, there are a lot of examples of “single entry point” systems out there, but it’s also not the"},{"type":"text","text":" "},{"type":"text","text":"majority. There are plenty of examples that do not fall into this paradigm, such as"},{"type":"text","text":" "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" conformances, all of UIKit and more. If you "},{"type":"emphasis","inlineContent":[{"type":"text","text":"are"}]},{"type":"text","text":" dealing with a single entry"},{"type":"text","text":" "},{"type":"text","text":"point system, then there are some really great super powers that can be unlocked…"}]},{"anchor":"Altered-execution-environments","level":2,"type":"heading","text":"Altered execution environments"},{"type":"paragraph","inlineContent":[{"type":"text","text":"One of the most interesting aspects of single entry point systems is that they have a well defined"},{"type":"text","text":" "},{"type":"text","text":"scope from beginning to end, and that makes it possible to easily alter their execution context."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, SwiftUI views have a powerful feature known as "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environment-values"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"They allow you to propagate values deep into a view hierarchy and can be overridden for just one"},{"type":"text","text":" "},{"type":"text","text":"small subset of the view tree."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following SwiftUI view stacks a header view on top of a footer view, and overrides the"},{"type":"text","text":" "},{"type":"text","text":"foreground color for the header:"}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView: View {","  var body: some View {","    VStack {","      HeaderView()","        .foregroundColor(.red)","      FooterView()","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".red"},{"type":"text","text":" foreground color will be applied to every view in "},{"type":"codeVoice","code":"HeaderView"},{"type":"text","text":", including deeply nested"},{"type":"text","text":" "},{"type":"text","text":"views. And most importantly, that style is applied to only to the header and not to the"},{"type":"text","text":" "},{"type":"codeVoice","code":"FooterView"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"foregroundColor"},{"type":"text","text":" view modifier is powered by "},{"overridingTitleInlineContent":[{"type":"text","text":"environment values"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environment-values","overridingTitle":"environment values"},{"type":"text","text":" under the"},{"type":"text","text":" "},{"type":"text","text":"hood, as can be seen by printing the type of "},{"type":"codeVoice","code":"ContentView"},{"type":"text","text":"’s body:"}]},{"type":"codeListing","syntax":"swift","code":["print(ContentView.Body.self)","\/\/ VStack<","\/\/   TupleView<(","\/\/     ModifiedContent<","\/\/       HeaderView,","\/\/       _EnvironmentKeyWritingModifier<Optional<Color>>","\/\/     >,","\/\/     FooterView","\/\/   )>","\/\/ >"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The presence of "},{"type":"codeVoice","code":"_EnvironmentKeyWritingModifier"},{"type":"text","text":" shows that an environment key is being written."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is an incredibly powerful feature of SwiftUI, and the only reason it works so well and is so"},{"type":"text","text":" "},{"type":"text","text":"easy to understand is specifically because SwiftUI views form a single entry point system. That"},{"type":"text","text":" "},{"type":"text","text":"makes it possible to alter the execution environment of "},{"type":"codeVoice","code":"HeaderView"},{"type":"text","text":" so that its foreground color"},{"type":"text","text":" "},{"type":"text","text":"is red, and that altered state does not affect the other parts of the view true, such as"},{"type":"text","text":" "},{"type":"codeVoice","code":"FooterView"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The same is possible with the Composable Architecture and the dependencies of features. For example,"},{"type":"text","text":" "},{"type":"text","text":"suppose some feature’s logic and behavior was decomposed into the logic for the “header” and"},{"type":"text","text":" "},{"type":"text","text":"“footer,” and that we wanted to alter the dependencies used in the header. This can be done using"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":".dependency"},{"type":"text","text":" method on reducers, which acts similarly to the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/view\/environment(_:_:)"},{"type":"text","text":" view modifier from SwiftUI:"}]},{"type":"codeListing","syntax":"swift","code":["struct Feature: ReducerProtocol {","  struct State {","    \/\/ ...","  }","  enum Action {","    \/\/ ...","  }","","  var body: some ReducerProtocolOf<Self> {","    Header()","      .dependency(\\.fileManager, .mock)","      .dependency(\\.userDefaults, .mock)","","    Footer()","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will override the "},{"type":"codeVoice","code":"fileManager"},{"type":"text","text":" and "},{"type":"codeVoice","code":"userDefaults"},{"type":"text","text":" dependency to be mocks for the "},{"type":"codeVoice","code":"Header"},{"type":"text","text":" "},{"type":"text","text":"feature (as well as all features called to from inside "},{"type":"codeVoice","code":"Header"},{"type":"text","text":"), but will leave the dependencies"},{"type":"text","text":" "},{"type":"text","text":"untouched for all other features, including "},{"type":"codeVoice","code":"Footer"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This pattern can also be repeated for server applications. It is possible to alter the execution"},{"type":"text","text":" "},{"type":"text","text":"environment on a per-request basis, and even for just a subset of the request-to-response lifecycle."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is incredibly powerful to be able to do this, but it all hinges on being able to express your"},{"type":"text","text":" "},{"type":"text","text":"system as a single point of entry. Without that it becomes a lot more difficult to alter the"},{"type":"text","text":" "},{"type":"text","text":"execution context of the system, or a sub-system, because there is not only one place to do so."}]},{"anchor":"Non-single-entry-point-systems","level":2,"type":"heading","text":"Non-single entry point systems"},{"type":"paragraph","inlineContent":[{"type":"text","text":"While this library thrives when applied to “single entry point” systems, it is still possible to use"},{"type":"text","text":" "},{"type":"text","text":"with other kinds of systems. You just have to be a little more careful. In particular, you must be"},{"type":"text","text":" "},{"type":"text","text":"careful where you add dependencies to your features and how you construct features that use"},{"type":"text","text":" "},{"type":"text","text":"dependencies."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When adding a dependency to a feature’s "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" conformance, you should make use of"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" only for the object’s instance properties:"}]},{"type":"codeListing","syntax":"swift","code":["final class FeatureModel: ObservableObject {","  @Dependency(\\.apiClient) var apiClient","  @Dependency(\\.date) var date","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And similarly for "},{"type":"codeVoice","code":"UIViewController"},{"type":"text","text":" subclasses:"}]},{"type":"codeListing","syntax":"swift","code":["final class FeatureViewController: UIViewController {","  @Dependency(\\.apiClient) var apiClient","  @Dependency(\\.date) var date","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then you are free to use those dependencies from anywhere within the model and controller."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, if you create a new model or controller from within an existing model or controller, you"},{"type":"text","text":" "},{"type":"text","text":"will need to take an extra step to make sure that the parent feature’s dependencies are propagated"},{"type":"text","text":" "},{"type":"text","text":"to the child."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if your SwiftUI model holds a piece of optional state that drives a sheet, then when"},{"type":"text","text":" "},{"type":"text","text":"hydrating that state you will want to wrap it in"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/withDependencies(from:operation:file:line:)-8e74m"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["final class FeatureModel: ObservableObject {","  @Published var editModel: EditModel?","","  @Dependency(\\.apiClient) var apiClient","  @Dependency(\\.date) var date","","  func editButtonTapped() {","    self.editModel = withDependencies(from: self) {","      EditModel()","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This makes it so that if "},{"type":"codeVoice","code":"FeatureModel"},{"type":"text","text":" were constructed with some of its dependencies overridden"},{"type":"text","text":" "},{"type":"text","text":"(see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/OverridingDependencies"},{"type":"text","text":"), then those changes will also be visible to "},{"type":"codeVoice","code":"EditModel"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The same principle holds for UIKit. When constructing a child view controller to be presented,"},{"type":"text","text":" "},{"type":"text","text":"be sure to wrap its construction in"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/withDependencies(from:operation:file:line:)-8e74m"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["final class FeatureViewController: UIViewController {","  @Dependency(\\.apiClient) var apiClient","  @Dependency(\\.date) var date","","  func editButtonTapped() {","    let controller = withDependencies(from: self) {","      EditViewController()","    }","    self.present(controller, animated: true, completion: nil)","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you make sure to always use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/withDependencies(from:operation:file:line:)-8e74m"},{"type":"text","text":" "},{"type":"text","text":"when constructing child models and controllers you can be sure that changes to dependencies at"},{"type":"text","text":" "},{"type":"text","text":"any layer of your application will be visible at any layer below it. See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/Lifetimes"},{"type":"text","text":" for"},{"type":"text","text":" "},{"type":"text","text":"more information on how dependency lifetimes work."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/dependencies\/singleentrypointsystems"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Dependencies\/documentation\/Dependencies\/SingleEntryPointSystems","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn about “single entry point” systems, and why they are best suited for this dependencies"},{"type":"text","text":" "},{"type":"text","text":"library, although it is possible to use the library with non-single entry point systems."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Single entry point systems","role":"article","modules":[{"name":"Dependencies"}]},"hierarchy":{"paths":[["doc:\/\/Dependencies\/documentation\/Dependencies"]]},"seeAlsoSections":[{"title":"Advanced","identifiers":["doc:\/\/Dependencies\/documentation\/Dependencies\/DesigningDependencies","doc:\/\/Dependencies\/documentation\/Dependencies\/OverridingDependencies","doc:\/\/Dependencies\/documentation\/Dependencies\/Lifetimes"],"generated":true}],"references":{"https://developer.apple.com/documentation/swiftui/environment-values":{"title":"“environment values”","titleInlineContent":[{"type":"text","text":"“environment values”"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environment-values","url":"https:\/\/developer.apple.com\/documentation\/swiftui\/environment-values"},"doc://Dependencies/documentation/Dependencies/Lifetimes":{"role":"article","title":"Dependency lifetimes","abstract":[{"type":"text","text":"Learn about the lifetimes of dependencies, how to prolong the lifetime of a dependency, and how"},{"type":"text","text":" "},{"type":"text","text":"dependencies are inherited."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/Lifetimes","kind":"article","type":"topic","url":"\/documentation\/dependencies\/lifetimes"},"http://github.com/pointfreeco/swift-composable-architecture":{"title":"The Composable Architecture","titleInlineContent":[{"type":"text","text":"The Composable Architecture"}],"type":"link","identifier":"http:\/\/github.com\/pointfreeco\/swift-composable-architecture","url":"http:\/\/github.com\/pointfreeco\/swift-composable-architecture"},"doc://Dependencies/documentation/Dependencies/withDependencies(from:operation:file:line:)-8e74m":{"role":"symbol","title":"withDependencies(from:operation:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withDependencies"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Model"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"R"},{"kind":"text","text":">("},{"kind":"externalParam","text":"from"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Model"},{"kind":"text","text":", "},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": () "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"},{"kind":"text","text":", "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":"?) "},{"kind":"keyword","text":"rethrows"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"}],"abstract":[{"type":"text","text":"Updates the current dependencies for the duration of a synchronous operation by taking the"},{"type":"text","text":" "},{"type":"text","text":"dependencies tied to a given object."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/withDependencies(from:operation:file:line:)-8e74m","kind":"symbol","type":"topic","url":"\/documentation\/dependencies\/withdependencies(from:operation:file:line:)-8e74m"},"https://developer.apple.com/documentation/swiftui/view/environment(_:_:)":{"title":".environment","titleInlineContent":[{"type":"codeVoice","code":".environment"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/view\/environment(_:_:)","url":"https:\/\/developer.apple.com\/documentation\/swiftui\/view\/environment(_:_:)"},"doc://Dependencies/documentation/Dependencies":{"role":"collection","title":"Dependencies","abstract":[{"type":"text","text":"A dependency management library inspired by SwiftUI’s “environment.”"}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies","kind":"symbol","type":"topic","url":"\/documentation\/dependencies"},"doc://Dependencies/documentation/Dependencies/OverridingDependencies":{"role":"article","title":"Overriding dependencies","abstract":[{"type":"text","text":"Learn how dependencies can be changed at runtime so that certain parts of your application can use"},{"type":"text","text":" "},{"type":"text","text":"different dependencies."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/OverridingDependencies","kind":"article","type":"topic","url":"\/documentation\/dependencies\/overridingdependencies"},"doc://Dependencies/documentation/Dependencies/DesigningDependencies":{"role":"article","title":"Designing dependencies","abstract":[{"type":"text","text":"Learn techniques on designing your dependencies so that they are most flexible for injecting into"},{"type":"text","text":" "},{"type":"text","text":"features and overriding for tests."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/DesigningDependencies","kind":"article","type":"topic","url":"\/documentation\/dependencies\/designingdependencies"}}}