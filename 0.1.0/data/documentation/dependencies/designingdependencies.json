{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Making it possible to control your dependencies is the most important step you can take towards"},{"type":"text","text":" "},{"type":"text","text":"making your features isolatable and testable. The second most important step after that is to design"},{"type":"text","text":" "},{"type":"text","text":"your dependencies in a way that maximizes their flexibility in tests and other situations."}]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We have an "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.pointfree.co\/collections\/dependencies"},{"type":"text","text":" dedicated to the topic of dependencies"},{"type":"text","text":" "},{"type":"text","text":"and how to best design and construct them."}]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most popular way to design dependencies in Swift is to use protocols. For example, if your"},{"type":"text","text":" "},{"type":"text","text":"feature needs to interact with an audio player, you might design a protocol with methods for"},{"type":"text","text":" "},{"type":"text","text":"playing, stopping, and more:"}]},{"type":"codeListing","syntax":"swift","code":["protocol AudioPlayer {","  func loop(_ url: URL) async throws","  func play(_ url: URL) async throws","  func setVolume(_ volume: Float) async","  func stop() async","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then you are free to make as many conformances of this protocol as you want, such as a"},{"type":"text","text":" "},{"type":"codeVoice","code":"LiveAudioPlayer"},{"type":"text","text":" that actually interacts with AVFoundation, or a "},{"type":"codeVoice","code":"MockAudioPlayer"},{"type":"text","text":" that doesn’t"},{"type":"text","text":" "},{"type":"text","text":"play any sounds, but does suspend in order to simulate that something is playing. You could even"},{"type":"text","text":" "},{"type":"text","text":"have an "},{"type":"codeVoice","code":"UnimplementedAudioPlayer"},{"type":"text","text":" conformance that invokes "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" when any method is invoked."},{"type":"text","text":" "},{"type":"text","text":"And all of those conformances can be used to specify the live, preview and test values for the"},{"type":"text","text":" "},{"type":"text","text":"dependency:"}]},{"type":"codeListing","syntax":"swift","code":["private enum AudioPlayerKey: DependencyKey {","  static let liveValue: any AudioPlayer = LiveAudioPlayer()","  static let previewValue: any AudioPlayer = MockAudioPlayer()","  static let testValue: any AudioPlayer = UnimplementedAudioPlayer()","}"]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/LivePreviewTest"},{"type":"text","text":" for more information on how to best leverage live, preview and test"},{"type":"text","text":" "},{"type":"text","text":"implementations of your dependencies."}]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This style of dependencies works just fine, and if it is what you are most comfortable with then"},{"type":"text","text":" "},{"type":"text","text":"there is no need to change."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, there is a small change one can make to this dependency to unlock even more power. Rather"},{"type":"text","text":" "},{"type":"text","text":"than designing the audio player as a protocol, we can use a struct with closure properties to"},{"type":"text","text":" "},{"type":"text","text":"represent the interface:"}]},{"type":"codeListing","syntax":"swift","code":["struct AudioPlayerClient {","  var loop: (_ url: URL) async throws -> Void","  var play: (_ url: URL) async throws -> Void","  var setVolume: (_ volume: Float) async -> Void","  var stop: () async -> Void","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, rather than defining types that conform to the protocol you construct values:"}]},{"type":"codeListing","syntax":"swift","code":["extension AudioPlayerClient {","  static let live = Self(\/* ... *\/)","  static let mock = Self(\/* ... *\/)","  static let unimplemented = Self(\/* ... *\/)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And to register the dependency you can leverage the struct that defines the interface. There’s no"},{"type":"text","text":" "},{"type":"text","text":"need to define a new type:"}]},{"type":"codeListing","syntax":"swift","code":["extension AudioPlayerClient: DependencyKey {","  static let liveValue = Self(\/* ... *\/)","  static let previewValue = Self(\/* ... *\/)","  static let testValue = Self(\/* ... *\/)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you design your dependencies in this way you can pick which dependency endpoints you need in your"},{"type":"text","text":" "},{"type":"text","text":"feature. For example, if you have a feature that needs an audio player to do its job, but it only"},{"type":"text","text":" "},{"type":"text","text":"needs the "},{"type":"codeVoice","code":"play"},{"type":"text","text":" endpoint, and doesn’t need to loop, set volume or stop audio, then you can specify"},{"type":"text","text":" "},{"type":"text","text":"a dependency on just that one function:"}]},{"type":"codeListing","syntax":"swift","code":["final class FeatureModel: ObservableObject {","  @Dependency(\\.audioPlayer.play) var play","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This can allow your features to better describe the minimal interface they need from dependencies,"},{"type":"text","text":" "},{"type":"text","text":"which can help a feature seem less intimidating."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also override the bare minimum of the dependency in tests. For example, suppose that one"},{"type":"text","text":" "},{"type":"text","text":"user flow of your feature you are testing invokes the "},{"type":"codeVoice","code":"play"},{"type":"text","text":" endpoint, but you don’t think any other"},{"type":"text","text":" "},{"type":"text","text":"endpoint will be called. Then you can write a test that overrides only that one single endpoint:"}]},{"type":"codeListing","syntax":"swift","code":["func testFeature() {","  let isPlaying = ActorIsolated(false)","","  let model = withDependencies {","    $0.audioPlayer.play = { _ in await isPlaying.setValue(true) }","  } operation: {","    FeatureModel()","  }","","  await model.play()","  XCTAssertEqual(isPlaying.value, true)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If this test passes you can be guaranteed that no other endpoints of the dependency are used in the"},{"type":"text","text":" "},{"type":"text","text":"user flow you are testing. If someday in the future more of the dependency is used, you will"},{"type":"text","text":" "},{"type":"text","text":"instantly get a test failure, letting you know that there is more behavior that you must assert on."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/dependencies\/designingdependencies"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Dependencies\/documentation\/Dependencies\/DesigningDependencies","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn techniques on designing your dependencies so that they are most flexible for injecting into"},{"type":"text","text":" "},{"type":"text","text":"features and overriding for tests."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Designing dependencies","role":"article","modules":[{"name":"Dependencies"}]},"hierarchy":{"paths":[["doc:\/\/Dependencies\/documentation\/Dependencies"]]},"seeAlsoSections":[{"title":"Advanced","identifiers":["doc:\/\/Dependencies\/documentation\/Dependencies\/OverridingDependencies","doc:\/\/Dependencies\/documentation\/Dependencies\/Lifetimes","doc:\/\/Dependencies\/documentation\/Dependencies\/SingleEntryPointSystems"],"generated":true}],"references":{"doc://Dependencies/documentation/Dependencies/Lifetimes":{"role":"article","title":"Dependency lifetimes","abstract":[{"type":"text","text":"Learn about the lifetimes of dependencies, how to prolong the lifetime of a dependency, and how"},{"type":"text","text":" "},{"type":"text","text":"dependencies are inherited."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/Lifetimes","kind":"article","type":"topic","url":"\/documentation\/dependencies\/lifetimes"},"doc://Dependencies/documentation/Dependencies/OverridingDependencies":{"role":"article","title":"Overriding dependencies","abstract":[{"type":"text","text":"Learn how dependencies can be changed at runtime so that certain parts of your application can use"},{"type":"text","text":" "},{"type":"text","text":"different dependencies."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/OverridingDependencies","kind":"article","type":"topic","url":"\/documentation\/dependencies\/overridingdependencies"},"https://www.pointfree.co/collections/dependencies":{"title":"entire series of episodes","titleInlineContent":[{"type":"text","text":"entire series of episodes"}],"type":"link","identifier":"https:\/\/www.pointfree.co\/collections\/dependencies","url":"https:\/\/www.pointfree.co\/collections\/dependencies"},"doc://Dependencies/documentation/Dependencies/SingleEntryPointSystems":{"role":"article","title":"Single entry point systems","abstract":[{"type":"text","text":"Learn about “single entry point” systems, and why they are best suited for this dependencies"},{"type":"text","text":" "},{"type":"text","text":"library, although it is possible to use the library with non-single entry point systems."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/SingleEntryPointSystems","kind":"article","type":"topic","url":"\/documentation\/dependencies\/singleentrypointsystems"},"doc://Dependencies/documentation/Dependencies":{"role":"collection","title":"Dependencies","abstract":[{"type":"text","text":"A dependency management library inspired by SwiftUI’s “environment.”"}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies","kind":"symbol","type":"topic","url":"\/documentation\/dependencies"},"doc://Dependencies/documentation/Dependencies/LivePreviewTest":{"role":"article","title":"Live, preview, and test dependencies","abstract":[{"type":"text","text":"Learn how to provide different implementations of your dependencies for use in the live application,"},{"type":"text","text":" "},{"type":"text","text":"as well as in Xcode previews, and even in tests."}],"identifier":"doc:\/\/Dependencies\/documentation\/Dependencies\/LivePreviewTest","kind":"article","type":"topic","url":"\/documentation\/dependencies\/livepreviewtest"}}}